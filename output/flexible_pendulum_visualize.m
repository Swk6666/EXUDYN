function flexible_pendulum_visualize(matFile, videoFile)
%FLEXIBLE_PENDULUM_VISUALIZE Visualize/animate Exudyn flexible pendulum data.
%
%   FLEXIBLE_PENDULUM_VISUALIZE(MATFILE) loads the simulation data exported by
%   flexible_pendulum.py (Craig–Bampton reduced-order model) and plays an
%   animation of both flexible links.
%
%   FLEXIBLE_PENDULUM_VISUALIZE(MATFILE, VIDEOFILE) additionally records the
%   animation to VIDEOFILE (e.g. 'pendulum.mp4'). Requires MATLAB's video
%   encoding support for the chosen container.
%
%   The MAT file is expected to contain fields such as:
%       time, beam1_nodes, beam1_surface_trigs, beam1_node_positions,
%       beam2_nodes, beam2_surface_trigs, beam2_node_positions, gravity,
%       frames_per_second, ...
%
%   Example:
%       flexible_pendulum_visualize('output/flexible_pendulum_sim.mat', ...
%                                   'flexible_pendulum.mp4');
%
%   Author: autogenerated helper

arguments
    matFile (1,1) string = "output/flexible_pendulum_sim.mat"
    videoFile (1,1) string = ""
end

if exist(matFile, 'file') ~= 2
    error('MAT file "%s" not found. Run the Python exporter first.', matFile);
end

S = load(matFile);

requiredFields = {"beam1_nodes","beam1_surface_trigs","beam2_nodes", ...
    "beam2_surface_trigs"};
for k = 1:numel(requiredFields)
    if ~isfield(S, requiredFields{k})
        error('Field %s missing from MAT file %s.', requiredFields{k}, matFile);
    end
end

% Fallback if trajectory data is absent
haveTraj1 = isfield(S,'beam1_node_positions');
haveTraj2 = isfield(S,'beam2_node_positions');
if ~(haveTraj1 && haveTraj2)
    warning('Trajectory data not available; using reference configuration only.');
end

timeVec = [];
if isfield(S,'time')
    timeVec = S.time(:);
elseif haveTraj1
    timeVec = (0:size(S.beam1_node_positions,1)-1).' ;
end

if isempty(timeVec)
    timeVec = (0:99).' * 0.05; % arbitrary placeholder
end

fps = 30;
if isfield(S,'frames_per_second') && ~isempty(S.frames_per_second)
    fps = S.frames_per_second(1);
elseif numel(timeVec) > 1
    fps = round(1/mean(diff(timeVec)));
end

beam1Nodes = double(S.beam1_nodes);
beam2Nodes = double(S.beam2_nodes);
beam1Tri = double(S.beam1_surface_trigs);
beam2Tri = double(S.beam2_surface_trigs);

if haveTraj1
    beam1Traj = double(S.beam1_node_positions);
else
    beam1Traj = repmat(reshape(beam1Nodes, 1, size(beam1Nodes,1), 3), 2, 1, 1);
end
if haveTraj2
    beam2Traj = double(S.beam2_node_positions);
else
    beam2Traj = repmat(reshape(beam2Nodes, 1, size(beam2Nodes,1), 3), 2, 1, 1);
end

nSteps = size(beam1Traj,1);
if haveTraj2
    nSteps = min(nSteps, size(beam2Traj,1));
else
    nSteps = size(beam2Traj,1);
end

% Prepare figure
fig = figure('Name','Flexible double pendulum (Craig–Bampton)', ...
    'Color','w','Renderer','opengl');
hold on; axis equal; grid on;
xlabel('x [m]'); ylabel('y [m]'); zlabel('z [m]');
view(0.234568180562796, 90);
set(gca,'Projection','orthographic');
set(gca,'FontSize',11);
cameraPosition = [0.0002, -0.4496, 11.5053];
set(gca,'CameraPosition', cameraPosition);
set(gca,'CameraTarget', [0.0002, -0.4496, -0.0005]);
set(gca,'CameraUpVector', [0, 1, 0]);
set(gca,'CameraViewAngle', 6.6086);

% Determine global bounds for consistent axis
allSamples = [reshape(beam1Traj, [], 3); reshape(beam2Traj, [], 3)];
mins = min(allSamples, [], 1);
maxs = max(allSamples, [], 1);
range = max(maxs - mins, [], 'all');
center = 0.5*(mins + maxs);
margin = 0.05*range;
lims = [center(1)-0.5*range-margin, center(1)+0.5*range+margin, ...
        center(2)-0.5*range-margin, center(2)+0.5*range+margin, ...
        center(3)-0.5*range-margin, center(3)+0.5*range+margin];
axis(lims);

% Initial vertices
verts1 = squeeze(beam1Traj(1,:,:));
verts2 = squeeze(beam2Traj(1,:,:));

hPatch1 = trisurf(beam1Tri, verts1(:,1), verts1(:,2), verts1(:,3), ...
    'FaceColor',[0.1 0.6 0.9], 'FaceAlpha',0.6, 'EdgeColor',[0 0.2 0.5], 'LineWidth',0.3);
hPatch2 = trisurf(beam2Tri, verts2(:,1), verts2(:,2), verts2(:,3), ...
    'FaceColor',[0.9 0.4 0.2], 'FaceAlpha',0.6, 'EdgeColor',[0.5 0.15 0], 'LineWidth',0.3);

rootIdx1 = double(S.beam1_root_nodes(:));
tipIdx1  = double(S.beam1_tip_nodes(:));
rootIdx2 = double(S.beam2_root_nodes(:));
tipIdx2  = double(S.beam2_tip_nodes(:));
rootMarker1 = plot3(verts1(rootIdx1,1), verts1(rootIdx1,2), ...
    verts1(rootIdx1,3), 'ko', 'MarkerFaceColor',[0 0.2 0.5]);
tipMarker1 = plot3(verts1(tipIdx1,1), verts1(tipIdx1,2), ...
    verts1(tipIdx1,3), 'ks', 'MarkerFaceColor',[0 0.2 0.5]);
rootMarker2 = plot3(verts2(rootIdx2,1), verts2(rootIdx2,2), ...
    verts2(rootIdx2,3), 'ko', 'MarkerFaceColor',[0.5 0.15 0]);
tipMarker2 = plot3(verts2(tipIdx2,1), verts2(tipIdx2,2), ...
    verts2(tipIdx2,3), 'ks', 'MarkerFaceColor',[0.5 0.15 0]);

if isfield(S,'gravity')
    gvec = S.gravity(:)';
    q = quiver3(0,0,0, gvec(1), gvec(2), gvec(3), 0.3, 'k', 'LineWidth',1.5, 'MaxHeadSize',0.5);
    text(gvec(1)*0.3, gvec(2)*0.3, gvec(3)*0.3, ' gravity', 'Color','k');
else
    q = []; %#ok<NASGU>
end

legend({'Beam 1','Beam 2'}, 'Location','northeastoutside');

% Configure video if requested
writeVideoFlag = strlength(videoFile) > 0;
if writeVideoFlag
    [~,~,ext] = fileparts(videoFile);
    if isempty(ext)
        videoFile = videoFile + ".mp4";
    end
    try
        vWriter = VideoWriter(videoFile,'MPEG-4');
    catch
        warning('Falling back to Motion JPEG AVI for video export.');
        vWriter = VideoWriter(videoFile,'Motion JPEG AVI');
    end
    vWriter.FrameRate = fps;
    open(vWriter);
    targetFrameSize = [];
else
    targetFrameSize = [];
end

% Animation loop
fprintf('Animating %d frames (fps ~ %g) ...\n', nSteps, fps);
for k = 1:nSteps
    verts1 = squeeze(beam1Traj(k,:,:));
    verts2 = squeeze(beam2Traj(k,:,:));

    set(hPatch1, 'Vertices', verts1);
    set(hPatch2, 'Vertices', verts2);

    set(rootMarker1, 'XData', verts1(rootIdx1,1), ...
        'YData', verts1(rootIdx1,2), ...
        'ZData', verts1(rootIdx1,3));
    set(tipMarker1, 'XData', verts1(tipIdx1,1), ...
        'YData', verts1(tipIdx1,2), ...
        'ZData', verts1(tipIdx1,3));
    set(rootMarker2, 'XData', verts2(rootIdx2,1), ...
        'YData', verts2(rootIdx2,2), ...
        'ZData', verts2(rootIdx2,3));
    set(tipMarker2, 'XData', verts2(tipIdx2,1), ...
        'YData', verts2(tipIdx2,2), ...
        'ZData', verts2(tipIdx2,3));

    title(sprintf('t = %.3f s', timeVec(min(k, numel(timeVec)))), 'FontSize', 12);
    drawnow limitrate;

    if writeVideoFlag
        frame = getframe(fig);
        if isempty(targetFrameSize)
            targetFrameSize = size(frame.cdata);
        else
            currentSize = size(frame.cdata);
            if any(currentSize(1:2) ~= targetFrameSize(1:2))
                frame.cdata = resizeFrame(frame.cdata, targetFrameSize(1:2));
            end
        end
        writeVideo(vWriter, frame);
    end
end

if writeVideoFlag
    close(vWriter);
    fprintf('Saved video to %s\n', videoFile);
end

end

function imgOut = resizeFrame(imgIn, targetHW)
%RESIZEFRAME Resize uint8 RGB image to target height/width using built-in tools.
    targetRows = targetHW(1);
    targetCols = targetHW(2);
    [rows, cols, ch] = size(imgIn);
    if rows == targetRows && cols == targetCols
        imgOut = imgIn;
        return;
    end
    if exist('imresize','file') == 2
        imgOut = imresize(imgIn, [targetRows, targetCols], 'nearest');
        return;
    end
    [X, Y] = meshgrid(1:cols, 1:rows);
    [Xi, Yi] = meshgrid(linspace(1, cols, targetCols), linspace(1, rows, targetRows));
    imgOut = zeros(targetRows, targetCols, ch, 'uint8');
    for c = 1:ch
        imgOut(:,:,c) = uint8(interp2(X, Y, double(imgIn(:,:,c)), Xi, Yi, 'linear', 0));
    end
end
