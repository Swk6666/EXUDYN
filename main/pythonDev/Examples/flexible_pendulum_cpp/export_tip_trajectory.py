"""Export the second pendulum tip trajectory from the Python and C++ runs.

The script reads the cached NPZ files generated by ``python_flexible_pendulum.py``
(``python_response.npz``) and ``flexible_pendulum_cpp`` (``cpp_response.npz``)
and creates a consolidated time series containing

- ``time``            : simulation time vector (seconds)
- ``tip_python``      : tip position from the Python run (x,y,z)
- ``tip_cpp``         : tip position from the C++ run (x,y,z)

The consolidated data are written to ``data/tip_trajectory.npz`` and, if SciPy
is available, also to ``data/tip_trajectory.mat``. In addition a CSV file is
produced for quick inspection (``time, x_py, y_py, z_py, x_cpp, y_cpp, z_cpp``).
"""

from __future__ import annotations

import numpy as np
from pathlib import Path

try:
    from scipy.io import savemat  # type: ignore
except ImportError:  # SciPy optional
    savemat = None  # type: ignore

DATA_DIR = Path(__file__).resolve().parent / "data"
PYTHON_RESPONSE = DATA_DIR / "python_response.npz"
CPP_RESPONSE = DATA_DIR / "cpp_response.npz"

if not PYTHON_RESPONSE.exists():
    raise FileNotFoundError(f"Missing Python response file: {PYTHON_RESPONSE}")
if not CPP_RESPONSE.exists():
    raise FileNotFoundError(f"Missing C++ response file: {CPP_RESPONSE}")

py_data = np.load(PYTHON_RESPONSE, allow_pickle=True)
cpp_data = np.load(CPP_RESPONSE, allow_pickle=True)

tip_py = py_data["tip_sensor"]
# First column is time, remaining columns are xyz.
time_py = tip_py[:, 0]
coords_py = tip_py[:, 1:4]

tip_cpp = cpp_data["tip_sensor"]
time_cpp = tip_cpp[:, 0]
coords_cpp = tip_cpp[:, 1:4]

# Align to the shorter length to avoid extrapolation if one run differs by a step
length = min(len(time_py), len(time_cpp))
if length == 0:
    raise RuntimeError("Tip response arrays are empty; re-run simulations first.")

# If the time grids differ slightly, prefer the Python time vector and clip the C++ data
aligned_time = time_py[:length]
coords_py = coords_py[:length, :]
coords_cpp = coords_cpp[:length, :]

# Pack into a consolidated dictionary
consolidated = {
    "time": aligned_time,
    "tip_python": coords_py,
    "tip_cpp": coords_cpp,
}

# Save NPZ for Python consumers
np.savez(DATA_DIR / "tip_trajectory.npz", **consolidated)

# Save MAT for MATLAB if SciPy is available
if savemat is not None:
    savemat(DATA_DIR / "tip_trajectory.mat", consolidated)

# Save a CSV for quick inspection
csv_path = DATA_DIR / "tip_trajectory.csv"
stacked = np.column_stack((aligned_time, coords_py, coords_cpp))
header = "time,tipPy_x,tipPy_y,tipPy_z,tipCpp_x,tipCpp_y,tipCpp_z"
np.savetxt(csv_path, stacked, delimiter=",", header=header, comments="")

print(f"Exported tip trajectory to:\n  {DATA_DIR / 'tip_trajectory.npz'}")
if savemat is not None:
    print(f"  {DATA_DIR / 'tip_trajectory.mat'}")
else:
    print("SciPy not available; skipped MAT export.")
print(f"  {csv_path}")
