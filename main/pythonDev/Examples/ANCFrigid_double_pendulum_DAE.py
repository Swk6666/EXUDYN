# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# This is an EXUDYN example
#
# Details:  Flexible–rigid double pendulum: first link as ANCF cable (2D),
#           second link as planar rigid body. Exports DAE matrices (M, K, D, C).
#
# Author:   Generated by assistant
# Date:     2025-09-14
#
# Notes:
# - Exports system matrices at the current configuration (initial state by default).
# - Saves .npz by default; tries to save .mat if SciPy is available.
# - Does not depend on rendering; set flags below if you want to simulate.
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

import os
import numpy as np

import exudyn as exu
from exudyn.utilities import *
import exudyn.graphics as graphics


def build_ancf_rigid_double_pendulum():
    """Builds a double pendulum: first link (ANCFCable2D), second link (RigidBody2D).

    Returns:
        (SC, mbs, data) where data is a dict of model references/ids for further use.
    """
    SC = exu.SystemContainer()
    mbs = SC.AddSystem()

    # ------------------------------
    # Parameters
    # ------------------------------
    g = [0, -9.81, 0]

    # First link (ANCF)
    L1 = 0.5
    nElem1 = 12
    E1 = 5e8       # steel-like
    rho1 = 7800.0
    h1 = 0.004
    b1 = 0.01
    A1 = b1 * h1
    I1 = b1 * (h1**3) / 12.0
    EI1 = E1 * I1
    EA1 = E1 * A1

    # Second link (rigid body rod)
    L2 = 0.4
    rho2 = 7800.0
    h2 = h1
    b2 = b1
    A2 = b2 * h2
    m2 = rho2 * A2 * L2
    J2 = m2 * (L2**2) / 12.0  # planar inertia around COM for slender rod

    # ------------------------------
    # Graphics / Ground
    # ------------------------------
    rect = [-0.4, -0.7, L1 + L2 + 0.4, 0.7]
    background = GraphicsDataRectangle(rect[0], rect[1], rect[2], rect[3], color=[0.9, 0.95, 1.0, 1.0])
    oGround = mbs.AddObject(ObjectGround(visualization=VObjectGround(graphicsData=[background])))

    # ------------------------------
    # Build ANCF first link
    # ------------------------------
    cableTemplate = Cable2D(
        physicsMassPerLength=rho1 * A1,
        physicsBendingStiffness=EI1,
        physicsAxialStiffness=EA1,
        physicsBendingDamping=0.01 * EI1,
        physicsAxialDamping=0.001 * EA1,
        visualization=VCable2D(drawHeight=h1)
    )

    pos0 = [0, 0, 0]
    pos1 = [L1, 0, 0]

    ancf = GenerateStraightLineANCFCable2D(
        mbs, pos0, pos1, nElem1, cableTemplate,
        massProportionalLoad=g,              # gravity for ANCF
        fixedConstraintsNode0=None,          # free; hinge will constrain
        fixedConstraintsNode1=None
    )
    ancf_nodes = ancf[0]
    ancf_objs = ancf[1]

    # Revolute joint: ground ↔ first ANCF node
    mGroundHinge = mbs.AddMarker(MarkerBodyPosition(bodyNumber=oGround, localPosition=pos0))
    mANCFstart = mbs.AddMarker(MarkerNodePosition(nodeNumber=ancf_nodes[0]))
    mbs.AddObject(ObjectJointRevolute2D(markerNumbers=[mGroundHinge, mANCFstart]))

    # ------------------------------
    # Build rigid second link
    # ------------------------------
    # Reference at COM initially at x = L1 + L2/2, horizontal (phi=0)
    nRB = mbs.AddNode(NodeRigidBody2D(referenceCoordinates=[L1 + 0.5 * L2, 0, 0]))

    # Simple rod graphics aligned with body x-axis
    rod_gfx = [graphics.Brick(centerPoint=[0, 0, 0], size=[L2, h2, h2], color=graphics.color.dodgerblue, addEdges=True)]

    oRB = mbs.AddObject(ObjectRigidBody2D(
        physicsMass=m2, physicsInertia=J2, nodeNumber=nRB,
        visualization=VObjectRigidBody2D(graphicsData=rod_gfx)
    ))

    # Gravity on rigid body
    mRBmass = mbs.AddMarker(MarkerBodyMass(bodyNumber=oRB))
    mbs.AddLoad(LoadMassProportional(markerNumber=mRBmass, loadVector=g))

    # small angular damping around hinge to stabilize (torque ~ c_theta * omega)
    nGroundCoord = mbs.AddNode(NodePointGround(referenceCoordinates=[0,0,0]))
    mGroundCoord = mbs.AddMarker(MarkerNodeCoordinate(nodeNumber=nGroundCoord, coordinate=0))
    mRBangle = mbs.AddMarker(MarkerNodeCoordinate(nodeNumber=nRB, coordinate=2))
    mbs.AddObject(CoordinateSpringDamper(markerNumbers=[mGroundCoord, mRBangle], stiffness=0.0, damping=5e-3,
                                         visualization=VCoordinateSpringDamper(show=False)))

    # Revolute joint: last ANCF node ↔ rigid body left end (localPosition at -L2/2,0)
    mANCFend = mbs.AddMarker(MarkerNodePosition(nodeNumber=ancf_nodes[-1]))
    mRBleft = mbs.AddMarker(MarkerBodyPosition(bodyNumber=oRB, localPosition=[-0.5 * L2, 0, 0]))
    mbs.AddObject(ObjectJointRevolute2D(markerNumbers=[mANCFend, mRBleft]))

    # ------------------------------
    # Assemble
    # ------------------------------
    mbs.Assemble()

    data = {
        'oGround': oGround,
        'ancf_nodes': ancf_nodes,
        'ancf_objs': ancf_objs,
        'nRB': nRB,
        'oRB': oRB,
        'L1': L1,
        'L2': L2,
        'm2': m2,
        'J2': J2
    }

    return SC, mbs, data


def export_system_matrices(mbs, output_dir):
    """Extract and save DAE matrices (M, K, D, C) using Static solver linearizations.

    Args:
        mbs: MainSystem
        output_dir: directory path to store outputs

    Returns:
        dict with matrices and meta information
    """
    os.makedirs(output_dir, exist_ok=True)

    sim = exu.SimulationSettings()
    sim.solutionSettings.writeSolutionToFile = False
    staticSolver = exu.MainSolverStatic()
    staticSolver.InitializeSolver(mbs, sim)

    nODE2 = staticSolver.GetODE2size()
    nODE1 = staticSolver.GetODE1size()
    nAE = staticSolver.GetAEsize()

    # 1) Mass matrix M
    staticSolver.ComputeMassMatrix(mbs, 1)
    Mfull = staticSolver.GetSystemMassMatrix()
    M = Mfull[:nODE2, :nODE2]

    # 2) Stiffness-like Jacobian K = ∂f/∂q (sign consistent with ComputeJacobianODE2RHS)
    staticSolver.ComputeJacobianODE2RHS(mbs, scalarFactor_ODE2=-1.0, scalarFactor_ODE2_t=0.0, scalarFactor_ODE1=0.0)
    J = staticSolver.GetSystemJacobian()
    K = J[:nODE2, :nODE2]

    # 3) Damping-like Jacobian D = ∂f/∂qdot
    staticSolver.ComputeJacobianODE2RHS(mbs, scalarFactor_ODE2=0.0, scalarFactor_ODE2_t=-1.0, scalarFactor_ODE1=0.0)
    Jt = staticSolver.GetSystemJacobian()
    D = Jt[:nODE2, :nODE2]

    # 4) Constraint Jacobian C (AE wrt ODE2 coordinates)
    C = None
    if nAE > 0:
        try:
            # try legacy/simple signature first
            staticSolver.ComputeJacobianAE(mbs, 1)
            Jae = staticSolver.GetSystemJacobian()
            # Heuristic extraction of C block
            if hasattr(Jae, 'shape'):
                r, c = Jae.shape
                if r == nAE and c >= nODE2:
                    C = Jae[:, :nODE2]
                elif r >= nODE2 + nAE and c >= nODE2:
                    C = Jae[nODE2:nODE2 + nAE, :nODE2]
            if C is None:
                # Fallback: try extended signature; may raise on older versions
                staticSolver.ComputeJacobianAE(mbs, scalarFactor_ODE2=1.0, scalarFactor_ODE2_t=0.0, scalarFactor_ODE1=0.0,
                                               velocityLevel=False)
                Jae = staticSolver.GetSystemJacobian()
                if hasattr(Jae, 'shape'):
                    r, c = Jae.shape
                    if r == nAE and c >= nODE2:
                        C = Jae[:, :nODE2]
                    elif r >= nODE2 + nAE and c >= nODE2:
                        C = Jae[nODE2:nODE2 + nAE, :nODE2]
        except Exception:
            C = None

    staticSolver.FinalizeSolver(mbs, sim)

    # Save to NPZ always; try MAT optionally
    npz_path = os.path.join(output_dir, 'ANCFrigid_double_pendulum_DAE_matrices.npz')
    save_dict = {
        'M': M, 'K': K, 'D': D,
        'nODE2': nODE2, 'nODE1': nODE1, 'nAE': nAE
    }
    if C is not None:
        save_dict['C'] = C
    np.savez(npz_path, **save_dict)

    mat_path = None
    try:
        import scipy.io as sio  # optional
        mat_path = os.path.join(output_dir, 'ANCFrigid_double_pendulum_DAE_matrices.mat')
        sio.savemat(mat_path, save_dict)
    except Exception:
        mat_path = None

    return {
        'M': M, 'K': K, 'D': D, 'C': C,
        'nODE2': nODE2, 'nODE1': nODE1, 'nAE': nAE,
        'npz': npz_path, 'mat': mat_path
    }


def main(run_simulation=True, export_dir='./output_matrices', pre_relax_static=False, pre_relax_dynamic=True):
    SC, mbs, data = build_ancf_rigid_double_pendulum()

    # Export DAE matrices
    mats = export_system_matrices(mbs, export_dir)

    print('=' * 70)
    print('柔-刚双摆（ANCF+刚体）DAE 矩阵导出完成')
    print('=' * 70)
    print(f"ODE2坐标数: {mats['nODE2']}")
    print(f"AE约束数:   {mats['nAE']}")
    print(f"M 形状: {mats['M'].shape}")
    print(f"K 形状: {mats['K'].shape}")
    print(f"D 形状: {mats['D'].shape}")
    if mats['C'] is not None:
        print(f"C 形状: {mats['C'].shape}")
    print(f"已保存: {mats['npz']}")
    if mats['mat']:
        print(f"已保存: {mats['mat']}")
    else:
        print('未保存 .mat（SciPy 不可用），已保存 .npz。')

    # Optional: dynamic simulation with visualization
    if run_simulation:
        # optional dynamic pre-relaxation (robust for mechanisms)
        if pre_relax_dynamic:
            simR = exu.SimulationSettings()
            simR.timeIntegration.numberOfSteps = int(0.5/0.001)
            simR.timeIntegration.endTime = 0.5
            simR.timeIntegration.verboseMode = 0
            simR.solutionSettings.writeSolutionToFile = False
            simR.linearSolverType = exu.LinearSolverType.EigenSparse
            simR.timeIntegration.newton.useModifiedNewton = True
            simR.timeIntegration.newton.maxIterations = 60
            simR.timeIntegration.newton.relativeTolerance = 1e-6
            simR.timeIntegration.newton.absoluteTolerance = 1e-8
            simR.timeIntegration.adaptiveStep = True
            simR.timeIntegration.generalizedAlpha.spectralRadius = 0.0  # heavy algorithmic damping
            mbs.SolveDynamic(simR)
            # copy relaxed state to initial and current, zero velocities
            u = mbs.systemData.GetODE2Coordinates()
            n = len(u)
            zero = np.zeros(n)
            mbs.systemData.SetODE2Coordinates(u, exu.ConfigurationType.Initial)
            mbs.systemData.SetODE2Coordinates_t(zero, exu.ConfigurationType.Initial)
            mbs.systemData.SetODE2Coordinates(u)
            mbs.systemData.SetODE2Coordinates_t(zero)

        sim = exu.SimulationSettings()
        tEnd = 50.0
        stepSize = 0.001  # 1 ms
        sim.timeIntegration.numberOfSteps = int(tEnd / stepSize)
        sim.timeIntegration.endTime = tEnd
        sim.timeIntegration.verboseMode = 1
        sim.solutionSettings.solutionWritePeriod = 0.005  # write often enough for viewer
        sim.solutionSettings.writeSolutionToFile = True
        sim.linearSolverType = exu.LinearSolverType.EigenSparse
        sim.timeIntegration.newton.useModifiedNewton = True
        # Newton tuning for robustness
        sim.timeIntegration.newton.relativeTolerance = 1e-6
        sim.timeIntegration.newton.absoluteTolerance = 1e-8
        sim.timeIntegration.newton.maxIterations = 40
        sim.timeIntegration.adaptiveStep = True
        # slightly damp high-freq. modes for robustness
        sim.timeIntegration.generalizedAlpha.spectralRadius = 0.6

        # basic viz settings
        SC.visualizationSettings.nodes.defaultSize = 0.01
        SC.visualizationSettings.nodes.drawNodesAsPoint = False
        SC.visualizationSettings.bodies.beams.crossSectionFilled = True
        SC.visualizationSettings.loads.show = False

        # live animation
        SC.renderer.Start()
        mbs.SolveDynamic(sim, showHints=True)
        SC.renderer.Stop()
        # replay viewer
        mbs.SolutionViewer()


if __name__ == '__main__':
    # Set run_simulation=True if you want to animate briefly after export
    main(run_simulation=True)
